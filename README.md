# LP-II
Sure, Avinash!
Hereâ€™s a simple implementation of Diffie-Hellman Key Exchange where:

User (Alice) enters her private key.

JavaScript (Bob) generates its own private key.

Then they both compute the shared secret based on a public prime p and primitive root g.


Here's the full working HTML + JavaScript code:

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Diffie-Hellman Key Exchange</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    input, button {
      margin: 10px 0;
      padding: 8px;
      width: 300px;
    }
    #result {
      margin-top: 20px;
      background-color: #f4f4f4;
      padding: 15px;
      border-radius: 8px;
    }
  </style>
</head>
<body>

  <h2>Diffie-Hellman Key Exchange (Alice & Bob)</h2>

  <label>Enter your private key (Alice):</label><br>
  <input type="number" id="alicePrivateKey" placeholder="Enter a secret number"><br>
  
  <button onclick="performKeyExchange()">Generate Shared Secret</button>

  <div id="result"></div>

  <script>
    // Fixed prime number (p) and primitive root (g)
    const p = 23; // prime number
    const g = 5;  // primitive root

    // Randomly generate Bob's private key
    const bobPrivateKey = Math.floor(Math.random() * (p-2)) + 2; // between 2 and p-1

    function modPow(base, exponent, modulus) {
      if (modulus === 1) return 0;
      let result = 1;
      base = base % modulus;
      while (exponent > 0) {
        if (exponent % 2 === 1) {
          result = (result * base) % modulus;
        }
        exponent = Math.floor(exponent / 2);
        base = (base * base) % modulus;
      }
      return result;
    }

    function performKeyExchange() {
      const alicePrivateKey = parseInt(document.getElementById('alicePrivateKey').value);
      if (isNaN(alicePrivateKey) || alicePrivateKey <= 1 || alicePrivateKey >= p) {
        alert('Please enter a valid private key between 2 and ' + (p-1));
        return;
      }

      // Public keys
      const alicePublicKey = modPow(g, alicePrivateKey, p);
      const bobPublicKey = modPow(g, bobPrivateKey, p);

      // Shared secret keys
      const aliceSharedSecret = modPow(bobPublicKey, alicePrivateKey, p);
      const bobSharedSecret = modPow(alicePublicKey, bobPrivateKey, p);

      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = `
        <b>Public Parameters:</b><br>
        Prime (p): ${p}<br>
        Primitive Root (g): ${g}<br><br>

        <b>Alice's Private Key:</b> ${alicePrivateKey}<br>
        <b>Alice's Public Key:</b> ${alicePublicKey}<br><br>

        <b>Bob's Private Key:</b> ${bobPrivateKey} (generated by system)<br>
        <b>Bob's Public Key:</b> ${bobPublicKey}<br><br>

        <b>Shared Secret Computed by Alice:</b> ${aliceSharedSecret}<br>
        <b>Shared Secret Computed by Bob:</b> ${bobSharedSecret}<br><br>

        <b>Result:</b> ${aliceSharedSecret === bobSharedSecret ? "Success! Shared secrets match." : "Error! Shared secrets do not match."}
      `;
    }
  </script>

</body>
</html>


---

How it works:

Step 1: User (Alice) inputs her private key.

Step 2: JavaScript (Bob) randomly generates a private key.

Step 3: Both compute their public keys and exchange them.

Step 4: Both compute the shared secret independently using the other's public key.

Step 5: If done correctly, both secrets will match.



---

Would you also like me to show a slightly more secure version using big integers (for larger primes) using a library like BigInt? It would be closer to real-world cryptography.
Would you like that?

